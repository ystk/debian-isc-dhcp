#! /bin/sh /usr/share/dpatch/dpatch-run
## CVE-2011-4539_CVE-2012-3955.dpatch by Nico Golde <nion@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' isc-dhcp-4.1.1-P1~/common/tree.c isc-dhcp-4.1.1-P1/common/tree.c
--- isc-dhcp-4.1.1-P1~/common/tree.c	2012-09-23 13:29:14.000000000 +0000
+++ isc-dhcp-4.1.1-P1/common/tree.c	2012-09-23 13:30:03.000000000 +0000
@@ -1124,6 +1124,7 @@
 		*result = 0;
 		memset(&re, 0, sizeof(re));
 		if (bleft && bright &&
+		    (left.data != NULL) && (right.data != NULL) &&
         	    (regcomp(&re, (char *)right.data, regflags) == 0) &&
 		    (regexec(&re, (char *)left.data, (size_t)0, NULL, 0) == 0))
 				*result = 1;
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' isc-dhcp-4.1.1-P1~/server/dhcpv6.c isc-dhcp-4.1.1-P1/server/dhcpv6.c
--- isc-dhcp-4.1.1-P1~/server/dhcpv6.c	2012-09-23 13:30:03.000000000 +0000
+++ isc-dhcp-4.1.1-P1/server/dhcpv6.c	2012-09-23 13:30:03.000000000 +0000
@@ -1835,9 +1835,6 @@
 			ia_reference(&tmp->ia, reply->ia, MDL);
 
 			/* Commit 'hard' bindings. */
-			tmp->hard_lifetime_end_time =
-				tmp->soft_lifetime_end_time;
-			tmp->soft_lifetime_end_time = 0;
 			renew_lease6(tmp->ipv6_pool, tmp);
 			schedule_lease_timeout(tmp->ipv6_pool);
 
@@ -2491,9 +2488,6 @@
 			ia_reference(&tmp->ia, reply->ia, MDL);
 
 			/* Commit 'hard' bindings. */
-			tmp->hard_lifetime_end_time =
-				tmp->soft_lifetime_end_time;
-			tmp->soft_lifetime_end_time = 0;
 			renew_lease6(tmp->ipv6_pool, tmp);
 			schedule_lease_timeout(tmp->ipv6_pool);
 
@@ -3356,9 +3350,6 @@
 			ia_reference(&tmp->ia, reply->ia, MDL);
 
 			/* Commit 'hard' bindings. */
-			tmp->hard_lifetime_end_time =
-				tmp->soft_lifetime_end_time;
-			tmp->soft_lifetime_end_time = 0;
 			renew_lease6(tmp->ipv6_pool, tmp);
 			schedule_lease_timeout(tmp->ipv6_pool);
 		}
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' isc-dhcp-4.1.1-P1~/server/mdb6.c isc-dhcp-4.1.1-P1/server/mdb6.c
--- isc-dhcp-4.1.1-P1~/server/mdb6.c	2012-09-23 13:30:03.000000000 +0000
+++ isc-dhcp-4.1.1-P1/server/mdb6.c	2012-09-23 13:30:59.000000000 +0000
@@ -313,6 +313,8 @@
 ia_remove_iasubopt(struct ia_xx *ia, struct iasubopt *iasubopt,
 		   const char *file, int line) {
 	int i, j;
+        if (ia == NULL || iasubopt == NULL)
+            return;
 
 	for (i=0; i<ia->num_iasubopt; i++) {
 		if (ia->iasubopt[i] == iasubopt) {
@@ -1002,29 +1004,48 @@
 	return insert_result;
 }
 
-/*
- * Renew an lease in the pool.
+
+/*!
+ * \brief Renew a lease in the pool.
  *
- * To do this, first set the new hard_lifetime_end_time for the resource,
- * and then invoke renew_lease6() on it.
+ * The hard_lifetime_end_time of the lease should be set to
+ * the current expiration time.
+ * The soft_lifetime_end_time of the lease should be set to
+ * the desired expiration time.
  *
- * WARNING: lease times must only be extended, never reduced!!!
- */
+ * This routine will compare the two and call the correct
+ * heap routine to move the lease.  If the lease is active
+ * and the new expiration time is greater (the normal case)
+ * then we call isc_heap_decreased() as a larger time is a
+ * lower priority.  If the new expiration time is less then
+ * we call isc_heap_increased().
+ *
+ * If the lease is abandoned then it will be on the active list
+ * and we will always call isc_heap_increased() as the previous
+ * expiration would have been all 1s (as close as we can get
+ * to infinite).
+ *
+ * If the lease is moving to active we call that routine
+ * which will move it from the inactive list to the active list.
+ *
+ * \param pool a pool the lease belongs to
+ * \param lease the lease to be renewed
+ *
+ * \return result of the renew operation (ISC_R_SUCCESS if successful,
+ *           ISC_R_NOMEMORY when run out of memory)
+*/
 isc_result_t
 renew_lease6(struct ipv6_pool *pool, struct iasubopt *lease) {
-	/*
-	 * If we're already active, then we can just move our expiration
-	 * time down the heap. 
-	 *
-	 * If we're abandoned then we are already on the active list
-	 * but we need to retag the lease and move our expiration
-	 * from infinite to the current value
-	 *
-	 * Otherwise, we have to move from the inactive heap to the 
-	 * active heap.
-	 */
+	time_t old_end_time = lease->hard_lifetime_end_time;
+	lease->hard_lifetime_end_time = lease->soft_lifetime_end_time;
+	lease->soft_lifetime_end_time = 0;
+
 	if (lease->state == FTS_ACTIVE) {
-		isc_heap_decreased(pool->active_timeouts, lease->heap_index);
+		if (old_end_time <= lease->hard_lifetime_end_time) {
+			isc_heap_decreased(pool->active_timeouts, lease->heap_index);
+		} else {
+			isc_heap_increased(pool->active_timeouts, lease->heap_index);
+		}
 		return ISC_R_SUCCESS;
 	} else if (lease->state == FTS_ABANDONED) {
 		char tmp_addr[INET6_ADDRSTRLEN];
@@ -1150,7 +1171,7 @@
  * Create a prefix by hashing the input, and using that for
  * the part subject to allocation.
  */
-static void
+void
 build_prefix6(struct in6_addr *pref, 
 	      const struct in6_addr *net_start_pref,
 	      int pool_bits, int pref_bits,
